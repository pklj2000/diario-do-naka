"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DevServer = void 0;
const events_1 = require("events");
const portfinder = require("portfinder");
const http = require("http");
const fs = require("fs");
const chalk = require("chalk");
const utils_1 = require("../utils");
class DevServer extends events_1.EventEmitter {
    constructor(opts) {
        super();
        this.opts = Object.assign({
            port: 8152,
        }, opts);
    }
    getMimeType(ext) {
        const mime = { "HTML": 'text/html, charset=utf-8', "TXT": 'text/plain', "SHTM": 'text/html, charset=utf-8', "CSS": 'text/css', "XML": 'text/xml', "GIF": 'image/gif', "JPG": 'image/jpeg', "JPEG": 'image/jpeg', "JS": 'application/x-javascript', "PNG": 'image/png', "TIF": 'image/tiff', "TIFF": 'image/tiff', "ICO": 'image/x-icon', "SVG": 'image/svg+xml', "JSON": 'application/json', "MP4": 'video/mp4', "MOV": 'video/quicktime', "M4V": 'video/x-m4v', "3GP": 'video/3gpp', "WOFF2": 'font/woff2', "WOFF": 'font/woff', "TTF": 'font/ttf', "PDF": 'application/pdf' };
        return mime[ext] != null ? mime[ext] : "text/html, charset=utf-8";
    }
    getFileExtension(path) {
        const last_path = (path.indexOf('/') != -1) ? path.split('/').pop() : path;
        return (last_path.indexOf('.') != -1) ? last_path.split('.').pop().toUpperCase() : null;
    }
    serveStaticFiles(port, host, path) {
        http.createServer((req, res) => {
            var _a;
            let filePath = ((_a = req.url) === null || _a === void 0 ? void 0 : _a.endsWith('/')) ? req.url + 'index.html' : req.url;
            fs.readFile(path + filePath, (error, content) => {
                if (error) {
                    if (error.code == 'ENOENT') {
                        res.writeHead(404);
                        res.end();
                    }
                    else {
                        res.writeHead(500);
                        res.end(error.code);
                    }
                }
                else {
                    res.writeHead(200, { "Content-Type": this.getMimeType(this.getFileExtension(filePath)) });
                    res.end(content, 'utf-8');
                }
            });
        }).listen(port, host);
    }
    ;
    async run() {
        this.port = await portfinder.getPortPromise({ port: this.opts.port });
        this.host = 'localhost' + (this.port != 80 ? ':' + this.port : '');
        process.env.PORT = this.port.toString();
        process.env.BROWSER = 'none';
        if (this.opts.command == null || this.opts.command == '' || this.opts.flags['no-dev']) {
            this.serveStaticFiles(this.port, 'localhost', this.opts.publicPath);
            this.protocol = 'http';
        }
        else {
            this.opts.command = this.opts.command.replace('$PORT', this.port.toString());
            (0, utils_1.warn)('RUNNING', 'Starting development server - ' + chalk.red(this.opts.command));
            (0, utils_1.spawnAsync)(this.opts.command, this.opts.flags['show-dev'], true).catch((error) => {
                console.log('\n\n');
                (0, utils_1.logError)('ERROR', 'An error occurred while starting the development server.');
                console.log(error.stdout);
                console.log('\n\n');
                console.log(error.stderr);
                //@ts-ignore
                originalProcessExit(1);
            });
            const waitPort = require('wait-port');
            await waitPort({ host: 'localhost', port: this.port, output: 'silent' });
            this.protocol = 'http'; //TO DO: get from dev server opened
        }
    }
}
exports.DevServer = DevServer;
