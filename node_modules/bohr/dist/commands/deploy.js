"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@oclif/core");
const login_1 = require("./login");
const chalk = require("chalk");
const utils_1 = require("../utils");
const axios_1 = require("axios");
const fs = require('graceful-fs');
const path = require('path');
const crypto = require('crypto');
const pjson = require('../../package.json');
require('dotenv').config({ path: path.resolve(process.cwd(), '.bohr.env') });
class Deploy extends core_1.Command {
    async run() {
        this.log('');
        var originalConsoleError = console.error;
        //@ts-ignore
        global.originalProcessExit = process.exit;
        //@ts-ignore
        process.exit = function processEmit(...args) {
            return;
        };
        console.error = function (...args) {
            try {
                if (args[0].indexOf('Error: timed out') != -1)
                    return;
            }
            catch (error) {
            }
            return originalConsoleError.apply(this, args);
        };
        const { flags } = await this.parse(Deploy);
        const Conf = require('conf');
        const config = new Conf();
        let DEV_MODE = (!pjson.bohrEnv) && (!process.env.GITHUB_ACTIONS);
        if (DEV_MODE || process.env.GITHUB_ACTIONS) {
            flags['show-install'] = true;
            flags['show-build'] = true;
        }
        let REPO_OWNER = null;
        let REPO_NAME = null;
        let REF_TYPE = process.env.BOHR_REF_TYPE || "BRANCH";
        let REF_NAME = null;
        let deployId = null;
        //Optional env
        let STACK = process.env.STACK;
        const MAIN_ENDPOINT = await (0, utils_1.getMainEndpoint)(DEV_MODE);
        let API_ROUTE = MAIN_ENDPOINT + '/api';
        let bohrApi = await (0, utils_1.getBohrAPI)(API_ROUTE, config.get('token'));
        (0, utils_1.warn)('WELCOME', 'Let\'s deploy it!...');
        const configFiles = JSON.stringify(await this.getConfigFiles());
        let firstDeployFromTemplate = false;
        let firstDeployUrl = null;
        let tryAutoLogin = false;
        const startDeploy = async () => {
            var _a, _b;
            let REPOSITORY = null;
            if (process.env.GITHUB_ACTIONS) {
                REPOSITORY = process.env.GITHUB_REPOSITORY;
                REF_NAME = process.env.GITHUB_REF_NAME;
            }
            else {
                const git = await (0, utils_1.getCurrentGit)();
                const defaultName = '/' + path.basename(process.cwd()).replace(/\s/g, '-');
                REPOSITORY = process.env.BOHR_REPOSITORY || (git === null || git === void 0 ? void 0 : git.REPOSITORY) || defaultName;
                REF_NAME = process.env.BOHR_REF_NAME || (git === null || git === void 0 ? void 0 : git.REF_NAME) || 'main';
            }
            REPO_OWNER = REPOSITORY.split('/')[0];
            REPO_NAME = REPOSITORY.split('/')[1];
            try {
                const coreAction = require('@actions/core');
                const startData = {
                    ID_TOKEN: (process.env.GITHUB_ACTIONS) ? await coreAction.getIDToken() : undefined,
                    GITHUB_TOKEN: process.env.GITHUB_TOKEN,
                    GITHUB_ACTIONS: process.env.GITHUB_ACTIONS,
                    REPO_OWNER,
                    REPO_NAME,
                    REF_TYPE,
                    REF_NAME,
                    CONFIG_FILES: configFiles,
                    GITHUB_ACTIONS_RUN_ID: process.env.GITHUB_RUN_ID
                };
                if (process.env.BOHR_CLI_DEBUG)
                    console.log(startData);
                const res = await bohrApi.post('/deploy/start' + ((process.env.GITHUB_ACTIONS) ? '?ga=1' : ''), startData);
                if (process.env.BOHR_CLI_DEBUG)
                    console.log(res.data);
                if (res.data.firstDeployFromTemplate) {
                    firstDeployFromTemplate = res.data.firstDeployFromTemplate;
                    firstDeployUrl = res.data.firstDeployUrl;
                    return;
                }
                deployId = res.data.deployId;
                Object.keys(res.data.env).forEach(function (key) { process.env[key] = res.data.env[key]; });
                if (process.env.GITHUB_ACTIONS) {
                    Object.assign(bohrApi.defaults.headers, {
                        'Cookie': null,
                        'Bohr-Auth-Bypass': res.data.token
                    });
                }
            }
            catch (error) {
                if (error.message.indexOf('Request failed with status code 401') != -1) {
                    if (!tryAutoLogin) {
                        tryAutoLogin = true;
                        (0, utils_1.loading)('DEV_MODE', 'Calling auto login...');
                        await login_1.default.run();
                        const config = new (require('conf'))();
                        Object.assign(bohrApi.defaults.headers, { 'Cookie': 'BohrSession=' + config.get('token') });
                        return await startDeploy();
                    }
                    else {
                        console.error('Please, run "login" command first.');
                        //@ts-ignore
                        originalProcessExit(1);
                    }
                }
                if (error.response) {
                    if (error.response.status == 403) {
                        if (((_a = error.response.data) === null || _a === void 0 ? void 0 : _a.code) == 7) {
                            this.error(chalk.red((_b = error.response.data) === null || _b === void 0 ? void 0 : _b.message));
                        }
                    }
                }
                this.error(error);
            }
        };
        await startDeploy();
        if (firstDeployFromTemplate) {
            (0, utils_1.info)(' DONE ', 'Site deployed successfully: ' + (0, utils_1.link)('https://' + firstDeployUrl));
            return;
        }
        let DEPLOY_PATH = (process.env.DEPLOY_PATH != null && process.env.DEPLOY_PATH.length > 0) ? process.env.DEPLOY_PATH : './';
        let PUBLIC_PATH = (process.env.PUBLIC_PATH != null && process.env.PUBLIC_PATH.length > 0) ? process.env.PUBLIC_PATH : DEPLOY_PATH;
        if (PUBLIC_PATH.substring(0, 1) == '/')
            PUBLIC_PATH = `.${PUBLIC_PATH}`;
        if (PUBLIC_PATH.substring(0, 2) != './')
            PUBLIC_PATH = `./${PUBLIC_PATH}`;
        //Install
        if (process.env.INSTALL_CMD && !flags['no-install']) {
            try {
                await (0, utils_1.runInstall)(process.env.INSTALL_CMD, flags['show-install'], true);
            }
            catch (error) {
                if (deployId) {
                    await bohrApi.post('/deploy/setDeployError', {
                        deployId,
                        REPO_OWNER,
                        REPO_NAME,
                        errorMessage: error.stderr
                    });
                }
                if (process.env.GITHUB_ACTIONS)
                    console.log('::endgroup::');
                this.log('\n\n');
                (0, utils_1.logError)('ERROR', 'An error occurred while installing the dependencies.');
                this.log(error.stdout);
                this.log('\n\n');
                this.log(error.stderr);
                this.exit(1);
            }
        }
        //Check for next.config.js
        await (0, utils_1.checkAndCreateNextConfigFile)();
        await (0, utils_1.checkAndCreateWorkflowFile)();
        //Build
        if (process.env.BUILD_CMD && !flags['no-build']) {
            if (process.env.TURBOREPO_TOKEN)
                process.env.BUILD_CMD = process.env.BUILD_CMD.replace('#TURBOREPO_TOKEN#', process.env.TURBOREPO_TOKEN);
            if (process.env.GITHUB_ACTIONS) {
                // @ts-ignore
                console.log('::group::' + chalk.inverse.bold['yellow'](` RUNNING `) + ' ' + chalk['yellow']('Building your site - ' + chalk.red(process.env.TURBOREPO_TOKEN ? process.env.BUILD_CMD.replace(process.env.TURBOREPO_TOKEN, '***') : process.env.BUILD_CMD)) + '\n');
            }
            else {
                (0, utils_1.warn)('RUNNING', 'Building your site - ' + chalk.red(process.env.TURBOREPO_TOKEN ? process.env.BUILD_CMD.replace(process.env.TURBOREPO_TOKEN, '***') : process.env.BUILD_CMD));
            }
            try {
                delete process.env.CI;
                await (0, utils_1.spawnAsync)(process.env.BUILD_CMD, flags['show-build'], true);
                if (process.env.GITHUB_ACTIONS)
                    console.log('::endgroup::');
                (0, utils_1.info)('SUCCESS', 'Your site has been successfully built.');
            }
            catch (error) {
                if (deployId) {
                    await bohrApi.post('/deploy/setDeployError', {
                        deployId,
                        REPO_OWNER,
                        REPO_NAME,
                        errorMessage: error.stderr
                    });
                }
                if (process.env.GITHUB_ACTIONS)
                    console.log('::endgroup::');
                this.log('\n\n');
                (0, utils_1.logError)('ERROR', 'An error occurred while building the site.');
                this.log(error.stdout);
                this.log('\n\n');
                this.log(error.stderr);
                this.exit(1);
            }
        }
        //Global vars
        const PUBLIC_PATH_FULL = path.resolve(PUBLIC_PATH);
        let allHashs = null;
        let allHashsManifest = null;
        let lambda_hash = '';
        let framework = '';
        let useLambda = false;
        let missingFiles = [];
        //Store hashes via api
        let hashes_on_api = true;
        const hashFile = (filePath) => new Promise(resolve => {
            const hash = crypto.createHash('sha256');
            const file = fs.createReadStream(filePath);
            file.on('data', (data) => {
                hash.update(data);
            });
            file.on('end', () => {
                resolve({ file: filePath.replace(PUBLIC_PATH_FULL, '').replace(/\\/g, '/'), hash: hash.digest('hex') });
            });
        });
        const createSha256CspHash = (content) => {
            return crypto.createHash('sha256').update(content).digest('hex');
        };
        const walk = function (dir, done) {
            var results = [];
            fs.readdir(dir, function (err, list) {
                if (err)
                    return done(err);
                var pending = list.length;
                if (!pending)
                    return done(null, results);
                list.forEach(function (file) {
                    file = path.resolve(dir, file);
                    fs.stat(file, function (err, stat) {
                        if (stat && stat.isDirectory()) {
                            walk(file, function (err, res) {
                                results = results.concat(res);
                                if (!--pending)
                                    done(null, results);
                            });
                        }
                        else {
                            const file_filter = file.replace(PUBLIC_PATH_FULL, '').toLowerCase().replace(/\\/g, '/');
                            if ((!file_filter.includes('/.git/')) &&
                                (!file_filter.includes('/.github/')) &&
                                (!file_filter.includes('/.worker/')) &&
                                (!file_filter.includes('/.turbo/')) &&
                                (!file_filter.includes('/node_modules/')) &&
                                (!file_filter.includes('/turborepo-cache/')) &&
                                (!file_filter.startsWith('/api/')) &&
                                (!file_filter.startsWith('/dist-api/')) &&
                                (!file_filter.endsWith('.env')) &&
                                (!file_filter.endsWith('/package.json')) &&
                                (!file_filter.endsWith('/package-lock.json')) &&
                                (!file_filter.endsWith('/yarn.lock')) &&
                                (!file_filter.endsWith('/.yarnrc')) &&
                                (!file_filter.endsWith('/.gitignore')) &&
                                (!file_filter.endsWith('README.md')) &&
                                (!file_filter.endsWith('next.conf.js'))) {
                                if (stat.size < 24 * 1024 * 1024) {
                                    results.push(file);
                                }
                                else {
                                    console.log('Ignoring file "' + file.replace(PUBLIC_PATH_FULL, '') + '" - too big');
                                }
                            }
                            if (!--pending)
                                done(null, results);
                        }
                    });
                });
            });
        };
        const hashDir = (filePath) => new Promise(resolve => {
            let hashs = [];
            walk(filePath, function (err, results) {
                if (err)
                    throw err;
                if (results.length == 0)
                    resolve(hashs);
                for (let i = 0; i < results.length; i++) {
                    hashFile(results[i]).then(hash => {
                        hashs.push(hash);
                        if (hashs.length == results.length)
                            resolve(hashs);
                    });
                }
            });
        });
        const kvBulk = async function (data, data_hash) {
            return new Promise(async (resolve, reject) => {
                bohrApi.put(`/cloudflare/kvBulk`, data).then((res) => {
                    if (res.data.success) {
                        if (hashes_on_api) {
                            let data = {
                                hashList: data_hash,
                                env: (process.env.BOHR_DG_NAME == 'main' ? 'main' : 'dev')
                            };
                            bohrApi.post(`/deploy/add_objects`, data).then((ret) => {
                                if (ret.data.error) {
                                    reject(ret.data.error);
                                }
                                else {
                                    resolve(true);
                                }
                            });
                        }
                        else {
                            resolve(true);
                        }
                    }
                    else {
                        reject('Upload file error.\n' + res.data);
                    }
                }).catch((error) => {
                    console.error(error);
                    //@ts-ignore
                    originalProcessExit(1);
                });
            });
        };
        const uploadFiles = async function () {
            return new Promise(async (resolve, reject) => {
                try {
                    (0, utils_1.warn)('RUNNING', 'Uploading files...');
                    let data = [];
                    let data_hash = [];
                    let data_len = 0;
                    let parallel_bulks = [];
                    for (let i = allHashs.length - 1; i >= 0; i--) {
                        if (hashes_on_api) {
                            if (!missingFiles.includes(allHashs[i].hash))
                                continue;
                        }
                        data.push(fs.readFileSync(PUBLIC_PATH_FULL + allHashs[i].file, { encoding: 'base64' }));
                        data_hash.push(allHashs[i].hash);
                        data_len += data[data.length - 1].length;
                        allHashs.pop();
                        if ((data_len >= 50000000) || (data.length >= 500)) {
                            parallel_bulks.push(kvBulk(data, data_hash));
                            data = [];
                            data_hash = [];
                            data_len = 0;
                        }
                        if (parallel_bulks.length >= 20) {
                            try {
                                await Promise.all(parallel_bulks);
                            }
                            catch (error) {
                                reject(error);
                            }
                            parallel_bulks = [];
                        }
                    }
                    if (data.length > 0) {
                        parallel_bulks.push(kvBulk(data, data_hash));
                    }
                    Promise.all(parallel_bulks).then(function () {
                        resolve(true);
                    }).catch(function (error) {
                        reject(error);
                    });
                }
                catch (error) {
                    reject(error);
                }
            });
        };
        const saveSiteConfig = async function (cb) {
            (0, utils_1.warn)('RUNNING', 'Deploying your site...');
            let assets = {};
            if (allHashsManifest != null) {
                for (let i = 0; i < allHashsManifest.length; i++) {
                    assets[allHashsManifest[i].file] = allHashsManifest[i].hash;
                }
            }
            let data = {
                lambda_hash: lambda_hash,
                stack: STACK,
                assets: assets,
                framework: framework,
                useLambda: useLambda
            };
            let data_value = JSON.stringify(data);
            const contentType = 'application/json';
            const jsonBuf = Buffer.from(data_value, "utf-8");
            let jsonKey = createSha256CspHash(jsonBuf);
            const resGetSignedUrl = await bohrApi.get(`/deploy/getSignedUrl?fileName=${jsonKey}&fileType=${contentType}`);
            const retUpload = await uploadToS3(jsonBuf, resGetSignedUrl.data.signedRequest);
            if (retUpload.status != 200) {
                throw ('saveSiteConfig error\n error saving site(1)');
            }
            delete data.assets;
            data.assets_key = jsonKey;
            data_value = JSON.stringify(data);
            bohrApi.post('/deploy/publish', { data_value, deployId, REF_TYPE, REF_NAME, REPO_OWNER, REPO_NAME }).then((res) => {
                cb(res.data);
            }).catch(async (error) => {
                if (deployId) {
                    await bohrApi.post('/deploy/setDeployError', {
                        deployId,
                        REPO_OWNER,
                        REPO_NAME,
                        errorMessage: error
                    });
                }
                console.error(error);
                //@ts-ignore
                originalProcessExit(1);
            });
        };
        const uploadToS3 = async function (zipBuf, signedRequest) {
            return await axios_1.default.put(signedRequest, zipBuf, {
                maxContentLength: Infinity,
                maxBodyLength: Infinity
            });
        };
        const getFunctionExists = async function (hash) {
            let functionExists = false;
            try {
                if (DEV_MODE && flags['no-install'] && flags['no-build'] && fs.existsSync('.next\\function.zip')) {
                    functionExists = true;
                }
                else {
                    const response = await bohrApi.get(`/deploy/getFunctionExists?hash=` + hash);
                    if (response.data.success) {
                        if (response.data.exists) {
                            functionExists = true;
                        }
                    }
                    else {
                        throw 'getFunctionExists error\n' + response.data;
                    }
                }
            }
            catch (error) {
                if (error.response) {
                    if (error.response.status == 401) {
                        throw 'Please, run "login" command first.';
                    }
                }
                throw 'getFunctionExists error\n' + error;
            }
            return functionExists;
        };
        const uploadZip = function (functionZipPath) {
            return new Promise(async (resolve, reject) => {
                try {
                    if ((process.env.BOHR_WEB_ADAPTER == '1') && (process.env.BOHR_WEB_ADAPTER_TYPE == 'nextjs')) {
                        framework = 'nextjs';
                        useLambda = true;
                    }
                    const hash = await hashFile(functionZipPath);
                    lambda_hash = hash.hash;
                    let functionExists = await getFunctionExists(hash.hash);
                    if (functionExists) {
                        (0, utils_1.info)('SUCCESS', 'Function uploaded successfully (bypass).');
                        return resolve(true);
                    }
                    else {
                        try {
                            const ZIP = fs.readFileSync(functionZipPath, { encoding: 'base64' });
                            const contentType = 'application/zip';
                            const zipBuf = (0, utils_1.b64ToBuf)(ZIP);
                            const resGetSignedUrl = await bohrApi.get(`/deploy/getSignedUrl?fileName=${hash.hash}&fileType=${contentType}`);
                            const retUpload = await uploadToS3(zipBuf, resGetSignedUrl.data.signedRequest);
                            if (retUpload.status != 200) {
                                throw 'deployLambda error\nupload error (1)';
                            }
                            if ((process.env.BOHR_WEB_ADAPTER != '1') && (process.env.BOHR_WEB_ADAPTER_TYPE != 'nextjs')) {
                                (0, utils_1.info)('SUCCESS', 'Function uploaded successfully.');
                            }
                            return resolve(true);
                        }
                        catch (error) {
                            throw 'deployLambda error\n' + error;
                        }
                    }
                }
                catch (error) {
                    return reject(error);
                }
            });
        };
        const deployLambda = async function () {
            return new Promise(async (resolve, reject) => {
                const API_PATH = DEPLOY_PATH + '/api';
                const DIST_API_PATH = 'dist-api';
                if (!fs.existsSync(API_PATH)) {
                    return resolve(true);
                }
                (0, utils_1.warn)('RUNNING', 'Uploading API function....');
                const { zipFunctions } = require('@netlify/zip-it-and-ship-it');
                async function ZipAndShip() {
                    try {
                        if (DEV_MODE && flags['no-install'] && flags['no-build'] && fs.existsSync('dist-api\\core.zip')) {
                            (0, utils_1.loading)('DEV_MODE', 'Using old "dist-api\\core.zip"...');
                            return [{ path: 'dist-api\\core.zip' }];
                        }
                        const archives = await zipFunctions(API_PATH, './' + DIST_API_PATH);
                        return archives;
                    }
                    catch (e) {
                        if (deployId) {
                            await bohrApi.post('/deploy/setDeployError', {
                                deployId,
                                REPO_OWNER,
                                REPO_NAME,
                                errorMessage: e
                            });
                        }
                        console.error(e);
                        //@ts-ignore
                        originalProcessExit(1);
                    }
                }
                ;
                ZipAndShip().then(async (result) => {
                    if (result.length == 0) {
                        return resolve(true);
                    }
                    try {
                        await uploadZip(result[0].path);
                        return resolve(true);
                    }
                    catch (error) {
                        return reject(error);
                    }
                }).catch(async (err) => {
                    if (deployId) {
                        await bohrApi.post('/deploy/setDeployError', {
                            deployId,
                            REPO_OWNER,
                            REPO_NAME,
                            errorMessage: err
                        });
                    }
                    return reject(err);
                });
            });
        };
        const chunkArray = function (myArray, chunk_size) {
            var index = 0;
            var arrayLength = myArray.length;
            var tempArray = [];
            for (index = 0; index < arrayLength; index += chunk_size) {
                let myChunk = myArray.slice(index, index + chunk_size);
                tempArray.push(myChunk);
            }
            return tempArray;
        };
        const getMissingFiles = async function () {
            return new Promise(async (resolve, reject) => {
                if (hashes_on_api) {
                    let onlyHashes = allHashs.map((el) => el.hash);
                    let parallel_bulks = [];
                    let chunk_size = 5000;
                    let chunks = chunkArray(onlyHashes, chunk_size);
                    chunks.forEach(el => {
                        let data = {
                            hashList: el,
                            env: (process.env.BOHR_DG_NAME == 'main' ? 'main' : 'dev')
                        };
                        parallel_bulks.push(bohrApi.post(`/deploy/get_missing_objects`, data, {}));
                    });
                    Promise.all(parallel_bulks).then((ret) => {
                        ret.forEach((el) => {
                            if (el.data.error) {
                                reject(el.data.error);
                            }
                            else {
                                missingFiles = [...missingFiles, ...el.data];
                            }
                        });
                        resolve(true);
                    }).catch((error) => {
                        reject(error);
                    });
                }
                else {
                    resolve(true);
                }
            });
        };
        const execStr = function (cmd) {
            try {
                const cp = require('child_process');
                const ret = cp.execSync(cmd, { shell: true, encoding: 'utf8' });
                return { success: true, result: ret };
            }
            catch (e) {
                return { success: false, error: e };
            }
        };
        const StaticFilesProcess = async function () {
            if (!await findIndexHTML(PUBLIC_PATH_FULL)) {
                if (deployId) {
                    await bohrApi.post('/deploy/setDeployError', {
                        deployId,
                        REPO_OWNER,
                        REPO_NAME,
                        errorMessage: "index.html not found in Public folder."
                    });
                    if (process.env.GITHUB_ACTIONS)
                        console.log('::endgroup::');
                    console.log('\n\n');
                    (0, utils_1.logError)('ERROR', 'index.html not found in Public folder.');
                    //@ts-ignore
                    originalProcessExit(1);
                }
            }
            if (!fs.existsSync(PUBLIC_PATH) || fs.readdirSync(PUBLIC_PATH).length == 0) {
                console.error("Invalid or empty public folder.");
                //@ts-ignore
                originalProcessExit(1);
            }
            return new Promise(async (resolve, reject) => {
                hashDir(PUBLIC_PATH).then(async function (hashs) {
                    allHashs = hashs;
                    allHashsManifest = hashs.slice();
                    try {
                        await getMissingFiles();
                    }
                    catch (error) {
                        hashes_on_api = false;
                    }
                    await uploadFiles();
                    (0, utils_1.info)('SUCCESS', 'Files uploaded successfully.');
                    resolve(true);
                });
            });
        };
        const StaticNextFilesProcess = async function () {
            if (!fs.existsSync('./.next/static') || fs.readdirSync('./.next/static').length == 0) {
                console.error("Invalid or empty public folder.");
                //@ts-ignore
                originalProcessExit(1);
            }
            (0, utils_1.info)('RUNNING', `Uploading static NextJs files.`);
            return new Promise(async (resolve, reject) => {
                hashDir('./.next/static').then(async function (hashs) {
                    hashDir('./public').then(async function (publicHashs) {
                        allHashs = hashs;
                        publicHashs.map((hash) => {
                            allHashs.push(hash);
                        });
                        allHashsManifest = hashs.slice();
                        try {
                            await getMissingFiles();
                        }
                        catch (error) {
                            hashes_on_api = false;
                        }
                        await uploadFiles();
                        (0, utils_1.info)('SUCCESS', `Static NextJs uploaded successfully.`);
                        resolve(true);
                    });
                });
            });
        };
        const findIndexHTML = async (PUBLIC_PATH_FULL) => new Promise(resolve => {
            fs.readdir(PUBLIC_PATH_FULL, async function (err, list) {
                if (err)
                    return false;
                await list.forEach(function (file) {
                    if (file.toLowerCase() == "index.html") {
                        resolve(true);
                    }
                });
                resolve(false);
            });
        });
        const arrPromises = [];
        if (process.env.BOHR_WEB_ADAPTER == '1') {
            if (process.env.BOHR_WEB_ADAPTER_TYPE == 'nextjs') {
                const functionZipPath = './.next/function.zip';
                if (!(DEV_MODE && flags['no-install'] && flags['no-build'] && fs.existsSync(functionZipPath))) {
                    await (0, utils_1.copyFolderRecursive)('./public', './.next/standalone/public');
                    await (0, utils_1.copyFolderRecursive)('./.next/static', './.next/standalone/.next/static');
                    (0, utils_1.createRunScript)('./.next/standalone', 'nextjs');
                    await (0, utils_1.createZip)('./.next/standalone', functionZipPath);
                }
                arrPromises.push(uploadZip(functionZipPath));
                arrPromises.push(StaticNextFilesProcess());
            }
            if (process.env.BOHR_WEB_ADAPTER_TYPE == 'php') {
                const functionZipPath = './function.zip';
                if (!(DEV_MODE && flags['no-install'] && flags['no-build'] && fs.existsSync(functionZipPath))) {
                    (0, utils_1.warn)('RUNNING', "Copying project files...");
                    await (0, utils_1.copyFolderRecursive)('./app', './.php/app');
                    await (0, utils_1.copyFolderRecursive)('./nginx', './.php/nginx');
                    await (0, utils_1.copyFolderRecursive)('./php', './.php/php');
                    (0, utils_1.info)(' DONE ', "Project files copied successfully.");
                    (0, utils_1.createRunScript)('./.php', 'php', 'bootstrap');
                    (0, utils_1.warn)('RUNNING', "Creating zip package...");
                    await (0, utils_1.createZip)('./.php', functionZipPath);
                    (0, utils_1.info)(' DONE ', "Zip created successfully.");
                }
                arrPromises.push(uploadZip(functionZipPath));
            }
            if (process.env.BOHR_WEB_ADAPTER_TYPE == 'nuxt') {
                const functionZipPath = './function.zip';
                if (!(DEV_MODE && flags['no-install'] && flags['no-build'] && fs.existsSync(functionZipPath))) {
                    (0, utils_1.warn)('RUNNING', "Creating zip package...");
                    await (0, utils_1.createZip)('./.output', functionZipPath);
                }
                arrPromises.push(uploadZip(functionZipPath));
            }
        }
        else {
            arrPromises.push(deployLambda());
            arrPromises.push(StaticFilesProcess());
        }
        Promise.all(arrPromises).then(async function () {
            await saveSiteConfig(function (ret) {
                (0, utils_1.info)(' DONE ', 'Site deployed successfully: ' + (0, utils_1.link)('https://' + ret.url));
                if (process.env.GITHUB_ACTIONS) {
                    execStr('echo "### bohr deploy! :rocket:" >> $GITHUB_STEP_SUMMARY');
                    execStr('echo "" >> $GITHUB_STEP_SUMMARY');
                    execStr('echo "## https://' + ret.url + '" >> $GITHUB_STEP_SUMMARY');
                }
            });
        }).catch(function (error) {
            console.log(error);
            //@ts-ignore
            originalProcessExit(1);
        });
    }
    async findFileByName(dir, name) {
        const matchedFiles = [];
        const files = await fs.readdirSync(dir);
        for (const file of files) {
            // Method 1:
            console.log(file);
            const filename = path.parse(file).name;
            if (filename === name) {
                matchedFiles.push(file);
            }
        }
        return matchedFiles;
    }
    ;
    async searchFiles(dirPath, configFiles = [], arrayOfFiles = []) {
        let files = fs.readdirSync(dirPath);
        arrayOfFiles = arrayOfFiles || [];
        for (const file of files) {
            if (file == 'node_modules')
                continue;
            if (file == '.next')
                continue;
            if (fs.statSync(dirPath + "/" + file).isDirectory()) {
                arrayOfFiles = await this.searchFiles(dirPath + "/" + file, configFiles, arrayOfFiles);
            }
            else {
                if (configFiles.includes(file)) {
                    arrayOfFiles.push({ name: file, path: path.resolve(dirPath, file) });
                }
            }
        }
        return arrayOfFiles;
    }
    async getConfigFiles() {
        const configFiles = ['_config.yml', 'babel.config.js', 'brunch-config.js', 'config.json', 'config.toml', 'config.yaml', 'hydrogen.config.js', 'hydrogen.config.ts', 'jest.config.js', 'package.json', 'package-lock.json', 'yarn.lock', 'remix.config.js', 'sanity.config.js', 'sanity.config.jsx', 'sanity.config.ts', 'sanity.config.tsx', 'sanity.json', 'tsconfig.json', 'tsconfig.root.json', 'turbo.json', 'vue.config.js'];
        let ret = [];
        const files = await this.searchFiles(process.cwd(), configFiles);
        for (let i = 0; i < files.length; i++) {
            try {
                let data = fs.readFileSync(path.resolve(files[i].path), { encoding: 'utf8' });
                if (files[i].name == 'package-lock.json' || files[i].name == 'yarn.lock')
                    data = '';
                ret.push({
                    file: files[i].name,
                    data: data
                });
            }
            catch (error) {
            }
        }
        return ret;
    }
}
exports.default = Deploy;
Deploy.description = 'Deploy a site';
Deploy.flags = {
    'no-install': core_1.Flags.boolean({ default: false, description: 'bypass install command' }),
    'no-build': core_1.Flags.boolean({ default: false, description: 'bypass build command' }),
    'show-install': core_1.Flags.boolean({ default: false, description: 'show install command output' }),
    'show-build': core_1.Flags.boolean({ default: false, description: 'show build command output' })
};
